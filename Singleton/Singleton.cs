using System;
using System.Collections.Generic;
using System.Text;

namespace Singleton
{

    // Суть паттерна Одиночка:
    // У класса есть только один экземпляр, и он предоставляет к нему глобальную точку доступа. 
    // При попытке создания данного объекта он создаётся только в том случае, если ещё не существует,
    // в противном случае возвращается ссылка на уже существующий экземпляр и нового выделения памяти не происходит.

    // Это потокобезопасная реализация Одиночки (также имеет название "double check lock"),
    // также она позволяет отложенную инициализацию объекта Одиночки.

    // Также существует "наивный" Одиночка, но в многопоточной среде его использование может привести к проблемам,
    // т.к. несколько потоков могут одновременно вызвать метод получения Одиночки 
    // и создать сразу несколько экземпляров объекта.

    public class Singleton 
    {
        // Это поле-индикатор, чтобы показать, что эта Одиночка действительно работает.
        public string Value { get; set; }

        // Приватный конструктор.
        private Singleton() { }

        // Ссылка на конкретный экземпляр данного объекта.
        private static Singleton _instance; 

        // Объект-блокировка для синхронизации потоков во первого доступа к Одиночке.
        private static readonly object _lock = new object();

        // Публичный метод, в результате вызова которого либо создатся новый объект и вернется ссылка на него,
        // либо на уже существующий объект.
        public static Singleton GetInstance(string value)
        {
            // Это условие нужно для того, чтобы не останавливать потоки блокировкой
            // если объект-одиночка уже создан.
            if (_instance == null)
            {
                // Если программа была запущена впервые, и объект-одиночка ещё не создан,
                // то несколько потоков могут одновременно пройти через условие выше и достигнуть блокировки.
                // Самый быстрый поток поставит блокировку и двинется внутрь секции, пока
                // другие будут здесь его ожидать.
                lock (_lock)
                {
                    // Первый поток достигает условия ниже и проходит внутрь, создавая объект-одиночку. 
                    // Как только этот поток покинет секцию и освободит блокировку, следующий поток может
                    // снова установить блокировку и зайти внутрь. 
                    // Но объект-одиночка уже будет создан, и данное условие существует,
                    // чтобы предотвратить повторное создание объекта.
                    if (_instance == null)
                    {
                        _instance = new Singleton();
                        _instance.Value = value;
                    }
                }
            }

            // После всех условий возвращаем ссылку на объект.
            return _instance;
        }

    }
}
